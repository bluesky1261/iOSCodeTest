//
//  SearchPresenter.swift
//  iOSCodeTest
//
//  Created by Joonghoo Im on 2021/04/17.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the 🐍 VIPER generator
//

import UIKit

final class SearchPresenter {

    // MARK: - Private properties -

    private unowned let view: SearchViewInterface
    private let interactor: SearchInteractorInterface
    private let wireframe: SearchWireframeInterface

    private var searchHistory: [SearchHistoryModel] = .init()

    private var searchSection: Int = 0
    private var searchSectionList: [Int:[PhotoModel]] = .init()

    private var isRequestingPhoto: Bool = false
    // MARK: - Lifecycle -

    init(view: SearchViewInterface, interactor: SearchInteractorInterface, wireframe: SearchWireframeInterface) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
}

// MARK: - Extensions -

extension SearchPresenter: SearchPresenterInterface {
    func viewDidLoad() {
        loadSearchHistory()
    }
    
    func getSearchHistory() -> [SearchHistoryModel] {
        return searchHistory
    }
    
    func saveSearchHistory(searchText: String) {
        interactor.saveSearchHistory(searchText: searchText)
    }

    func loadSearchHistory() {
        searchHistory = interactor.loadSearchHistory()
        self.view.updateSearchHistory()
    }

    func clearSearchHistory() {
        interactor.clearSearchHistory()
        searchHistory = .init()
        self.view.updateSearchHistory()
    }

    func searchPhoto(searchText: String) {
        isRequestingPhoto = true
        // Unsplash API는 1페이지부터 유의미한 데이터가 존재하여 section + 1을 함. Section:0 -> Page:1
        interactor.searchPhoto(page: searchSection + 1, searchText: searchText) { (photoModel) in
            guard let photoModel = photoModel else { return }

            self.searchSectionList[self.searchSection] = photoModel

            DispatchQueue.main.async {
                self.view.updateSearchList(section: self.searchSection)
                self.isRequestingPhoto = false
            }
        }
    }

    func getSearchSection() -> Int {
        return searchSection
    }

    func getSearchSectionList(for section: Int) -> [PhotoModel] {
        return searchSectionList[section] ?? [PhotoModel]()
    }

    func getSearchSectionCount() -> Int {
        return searchSectionList.count
    }

    func moveToDetail(section: Int, index: Int) {
        wireframe.navigate(to: .detail(self, section, index, searchSectionList))
    }

    func requestMorePhoto(searchText: String) {
        if !isRequestingPhoto {
            searchSection += 1
            searchPhoto(searchText: searchText)
        }
    }

    func clearSearch() {
        searchSection = 0
        searchSectionList = .init()
    }
}

extension SearchPresenter: DelegatePresenterInterface {
    func passData(sender: PresenterInterface, data: [String : Any]?) {
        switch sender {
        case is DetailPresenter:
            guard let data = data
                , let section = data["section"] as? Int
                , let index = data["index"] as? Int
                , let photoModels = data["photoModels"] as? [Int:[PhotoModel]] else { return }

            searchSectionList = photoModels

            DispatchQueue.main.async {
                self.view.updateSearchListWithPosition(currentSection: section, currentIndex: index)
            }
        default:
            print("There is no defined sender.")
        }
    }
}
